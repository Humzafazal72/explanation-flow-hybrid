<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>AI Tutor (Unified Mode)</title>
    <style>
      body {
        font-family: sans-serif;
        background: #f5f5f5;
        padding: 20px;
        margin: 0;
      }
      button {
        margin: 5px;
        padding: 8px 16px;
        font-size: 14px;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Main content layout */
      .content-wrapper {
        display: flex;
        gap: 20px;
        margin: 20px 0;
      }

      /* Whiteboard section */
      #whiteboard {
        flex: 1;
        background: white;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 20px;
        min-height: 300px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      #whiteboard h3 {
        margin-top: 0;
        border-bottom: 2px solid #333;
        padding-bottom: 10px;
      }

      .snippet-item {
        padding: 10px;
        margin: 10px 0;
        background: #f9f9f9;
        border-left: 4px solid #4caf50;
        font-size: 16px;
        line-height: 1.6;
      }

      /* Subtitles section */
      #subtitles-container {
        flex: 1;
        background: #2c3e50;
        color: white;
        border-radius: 8px;
        padding: 20px;
        min-height: 300px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      #subtitles-container h3 {
        margin-top: 0;
        border-bottom: 2px solid #34495e;
        padding-bottom: 10px;
        color: #ecf0f1;
      }

      #subtitles {
        font-size: 18px;
        line-height: 1.8;
        color: #ecf0f1;
      }

      /* Diagram section */
      #diagram-section {
        background: white;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
        text-align: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      #diagram-section h3 {
        margin-top: 0;
        border-bottom: 2px solid #333;
        padding-bottom: 10px;
      }

      #diagram {
        max-width: 100%;
        max-height: 500px;
        margin: 20px auto;
        display: none;
      }

      #diagram.visible {
        display: block;
      }

      .no-diagram {
        color: #999;
        font-style: italic;
        padding: 40px;
      }

      #log {
        background: #111;
        color: #0f0;
        padding: 8px;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
        border-radius: 4px;
        margin-top: 20px;
      }

      .voicebot-active {
        background: #ffe6e6;
        border: 2px solid #ff4444;
      }

      .voicebot-active #whiteboard,
      .voicebot-active #subtitles-container,
      .voicebot-active #diagram-section {
        opacity: 0.3;
      }

      #status,
      #metadata {
        padding: 10px;
        margin: 10px 0;
        background: white;
        border-radius: 4px;
      }

      /* Voicebot Popup Modal */
      #voicebot-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      #voicebot-modal.active {
        display: flex;
      }

      .voicebot-content {
        background: white;
        border-radius: 12px;
        width: 95%;
        max-width: 1400px;
        height: 85%;
        max-height: 800px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .voicebot-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 3px solid #5a67d8;
      }

      .voicebot-header h2 {
        margin: 0;
        font-size: 24px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .mic-indicator {
        width: 16px;
        height: 16px;
        background: #ff4444;
        border-radius: 50%;
        animation: pulse 1.5s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.5;
          transform: scale(1.2);
        }
      }

      .close-voicebot {
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid white;
        color: white;
        padding: 10px 20px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s;
      }

      .close-voicebot:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.05);
      }

      .voicebot-body {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        background: #f8f9fa;
        display: flex;
        gap: 20px;
      }

      .voicebot-left {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .voicebot-right {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      #voicebot-board {
        background: white;
        border: 3px solid #333;
        border-radius: 8px;
        padding: 25px;
        min-height: 300px;
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.05);
        flex: 1;
      }

      #voicebot-board h3 {
        margin-top: 0;
        color: #333;
        border-bottom: 3px solid #667eea;
        padding-bottom: 15px;
        font-size: 22px;
      }

      #voicebot-diagram-section {
        background: white;
        border: 3px solid #333;
        border-radius: 8px;
        padding: 25px;
        flex: 1;
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
      }

      #voicebot-diagram-section h3 {
        margin-top: 0;
        color: #333;
        border-bottom: 3px solid #ff9800;
        padding-bottom: 15px;
        font-size: 22px;
      }

      #voicebot-diagram-content {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      .diagram-placeholder {
        text-align: center;
        color: #999;
        font-style: italic;
        padding: 40px;
      }

      .diagram-generating {
        text-align: center;
        color: #667eea;
        font-size: 18px;
      }

      .diagram-generating .spinner {
        width: 60px;
        height: 60px;
        border: 5px solid #e0e0e0;
        border-top: 5px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .diagram-error {
        text-align: center;
        color: #e91e63;
        padding: 40px;
      }

      #voicebot-diagram-img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        display: none;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      #voicebot-diagram-img.visible {
        display: block;
      }

      .board-item {
        padding: 15px 20px;
        margin: 15px 0;
        border-radius: 8px;
        font-size: 18px;
        line-height: 1.8;
        animation: slideIn 0.3s ease-out;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .board-item.equation {
        background: #e3f2fd;
        border-left: 5px solid #2196f3;
      }

      .board-item.definition {
        background: #f3e5f5;
        border-left: 5px solid #9c27b0;
      }

      .board-item.key_point {
        background: #fff3e0;
        border-left: 5px solid #ff9800;
      }

      .board-item.diagram_label {
        background: #e8f5e9;
        border-left: 5px solid #4caf50;
      }

      .board-item.examples {
        background: #fce4ec;
        border-left: 5px solid #e91e63;
      }

      .board-item-type {
        font-size: 12px;
        font-weight: bold;
        text-transform: uppercase;
        opacity: 0.7;
        margin-bottom: 8px;
        letter-spacing: 1px;
      }

      .board-item-content {
        font-size: 20px;
        font-weight: 500;
        color: #333;
      }

      .empty-board {
        text-align: center;
        color: #999;
        font-style: italic;
        padding: 60px 20px;
        font-size: 18px;
      }

      .voicebot-status {
        background: rgba(102, 126, 234, 0.1);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        text-align: center;
        color: #667eea;
        font-weight: 500;
      }
    </style>
  </head>
  <body>
    <h2>AI Tutor (Gemini)</h2>
    <div id="status">Status: Not connected</div>
    <div id="metadata"></div>

    <hr />
    <button id="start">Start</button>
    <button id="pause">Pause</button>
    <button id="resume">Resume</button>
    <button id="ask">Ask Tutor üó£</button>
    <button id="exitVoicebot" style="display: none">Exit Voicebot ‚Ü©</button>
    <hr />

    <div class="content-wrapper">
      <div id="whiteboard">
        <h3>üìù Whiteboard</h3>
        <div id="whiteboard-content"></div>
      </div>

      <div id="diagram-section" style="flex: 1; margin: 0">
        <h3>üìä Diagram</h3>
        <img id="diagram" alt="Concept Diagram" />
        <div id="no-diagram" class="no-diagram">No diagram for this step</div>
      </div>
    </div>

    <div id="subtitles-container" style="margin-top: 20px">
      <h3>üí¨ Subtitles</h3>
      <div id="subtitles"></div>
    </div>

    <!-- Voicebot Modal -->
    <div id="voicebot-modal">
      <div class="voicebot-content">
        <div class="voicebot-header">
          <h2>
            <span class="mic-indicator"></span>
            Interactive Tutor
          </h2>
          <button
            class="close-voicebot"
            onclick="document.getElementById('exitVoicebot').click()"
          >
            Exit Session ‚Ü©
          </button>
        </div>
        <div class="voicebot-body">
          <div class="voicebot-left">
            <div class="voicebot-status">
              üéôÔ∏è Speak naturally - I'm listening and ready to help!
            </div>
            <div id="voicebot-board">
              <h3>üìã Learning Board</h3>
              <div id="voicebot-board-content">
                <div class="empty-board">
                  Board items will appear here as we discuss...
                </div>
              </div>
            </div>
          </div>

          <div class="voicebot-right">
            <div id="voicebot-diagram-section">
              <h3>üé® Visual Diagram</h3>
              <div id="voicebot-diagram-content">
                <div class="diagram-placeholder">
                  Ask me to create a diagram to visualize concepts!
                </div>
                <img id="voicebot-diagram-img" alt="Generated Diagram" />
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <hr />
    <pre id="log"></pre>

    <script>
      let ws,
        audioCtx,
        currentSrc = null;
      let STATE = "IDLE",
        MODE = "EXPLANATION";
      let CURRENT_STEP = 0,
        TOTAL_STEPS = 0;
      let audioChunks = [],
        isPlaying = false,
        isPaused = false;
      let SAVED_STATE = null;
      let SAVED_STEP = null;
      let typeWriterTimeout = null;

      // ---------- Helpers ----------
      function log(msg) {
        const box = document.getElementById("log");
        box.textContent += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
        box.scrollTop = box.scrollHeight;
      }

      function setSubtitle(txt) {
        document.getElementById("subtitles").innerText = txt;
      }

      function clearSubtitle() {
        stopTypewriter();
        document.getElementById("subtitles").innerText = "";
      }

      function updateWhiteboard(snippets) {
        const wb = document.getElementById("whiteboard-content");
        wb.innerHTML = "";

        if (snippets && snippets.length > 0) {
          snippets.forEach((snippet) => {
            const div = document.createElement("div");
            div.className = "snippet-item";
            div.textContent = snippet;
            wb.appendChild(div);
          });
        }
      }

      function updateDiagram(url) {
        const img = document.getElementById("diagram");
        const noImg = document.getElementById("no-diagram");

        if (url) {
          img.src = url;
          img.classList.add("visible");
          noImg.style.display = "none";
        } else {
          img.classList.remove("visible");
          img.src = "";
          noImg.style.display = "block";
        }
      }

      function clearAllSections() {
        clearSubtitle();
        updateWhiteboard([]);
        updateDiagram(null);
      }

      function showVoicebotModal() {
        document.getElementById("voicebot-modal").classList.add("active");
        clearVoicebotBoard();
        resetVoicebotDiagram();
      }

      function hideVoicebotModal() {
        document.getElementById("voicebot-modal").classList.remove("active");
      }

      function clearVoicebotBoard() {
        const board = document.getElementById("voicebot-board-content");
        board.innerHTML =
          '<div class="empty-board">Board items will appear here as we discuss...</div>';
      }

      function resetVoicebotDiagram() {
        const container = document.getElementById("voicebot-diagram-content");
        container.innerHTML =
          '<div class="diagram-placeholder">Ask me to create a diagram to visualize concepts!</div><img id="voicebot-diagram-img" alt="Generated Diagram">';
      }

      function showDiagramGenerating() {
        const container = document.getElementById("voicebot-diagram-content");
        container.innerHTML = `
    <div class="diagram-generating">
      <div class="spinner"></div>
      <p><strong>Creating your diagram...</strong></p>
      <p style="font-size: 14px; color: #999;">This may take a few moments</p>
    </div>
    <img id="voicebot-diagram-img" alt="Generated Diagram">
  `;
        log("Diagram generation started");
      }

      function showDiagramReady(url) {
        const container = document.getElementById("voicebot-diagram-content");
        container.innerHTML =
          '<img id="voicebot-diagram-img" alt="Generated Diagram">';

        const img = document.getElementById("voicebot-diagram-img");
        img.src = url;
        img.classList.add("visible");

        log("Diagram ready and displayed");
      }

      function showDiagramError() {
        const container = document.getElementById("voicebot-diagram-content");
        container.innerHTML = `
    <div class="diagram-error">
      <p style="font-size: 20px; margin-bottom: 10px;">‚ö†Ô∏è Oops!</p>
      <p>Failed to generate the diagram.</p>
      <p style="font-size: 14px; margin-top: 10px;">Please try asking again.</p>
    </div>
    <img id="voicebot-diagram-img" alt="Generated Diagram">
  `;
        log("Diagram generation failed");
      }

      function addToVoicebotBoard(content, type) {
        const board = document.getElementById("voicebot-board-content");

        // Remove empty message if it exists
        const emptyMsg = board.querySelector(".empty-board");
        if (emptyMsg) {
          emptyMsg.remove();
        }

        // Create new board item
        const item = document.createElement("div");
        item.className = `board-item ${type}`;

        const typeLabel = document.createElement("div");
        typeLabel.className = "board-item-type";
        typeLabel.textContent = type.replace(/_/g, " ");

        const contentDiv = document.createElement("div");
        contentDiv.className = "board-item-content";
        contentDiv.textContent = content;

        item.appendChild(typeLabel);
        item.appendChild(contentDiv);
        board.appendChild(item);

        // Scroll to bottom
        board.parentElement.scrollTop = board.parentElement.scrollHeight;

        log(`Board item added: [${type}] ${content}`);
      }

      async function initAudio() {
        if (!audioCtx)
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === "suspended") await audioCtx.resume();
      }

      // ------------------- TypeWriter ---------------------------
      function stopTypewriter() {
        if (typeWriterTimeout) {
          clearTimeout(typeWriterTimeout);
          typeWriterTimeout = null;
        }
      }

      async function typewriter(el, text, speed = 50) {
        stopTypewriter();
        el.innerHTML = "";
        let i = 0;

        return new Promise((res) => {
          (function type() {
            if (i < text.length) {
              el.innerHTML += text[i++];
              typeWriterTimeout = setTimeout(type, speed);
            } else {
              typeWriterTimeout = null;
              res();
            }
          })();
        });
      }

      // ---------- WS Setup ----------
      function connect() {
        ws = new WebSocket("ws://localhost:8000/ws/explanation/466");
        ws.onopen = () => {
          document.getElementById("status").innerText = "Connected ‚úì";
          log("WebSocket connected");
        };

        ws.onmessage = async (e) => {
          const msg = JSON.parse(e.data);

          if (msg.type === "METADATA") {
            TOTAL_STEPS = msg.num_steps;
            document.getElementById("metadata").innerText =
              `Concept: ${msg.name} | Steps: ${TOTAL_STEPS}`;
          } else if (msg.type === "TEXT_FULL") {
            // Update whiteboard with snippets
            if (msg.snippet) {
              updateWhiteboard(msg.snippet);
            } else {
              updateWhiteboard([]);
            }

            // Update diagram
            updateDiagram(msg.img_url);

            // Update subtitles with transcription
            typewriter(document.getElementById("subtitles"), msg.text);
          } else if (msg.type === "AUDIO_CHUNK") addAudio(msg.data);
          else if (msg.type === "STREAM_EXIT") playAudio();
          else if (msg.type === "VOICEBOT_INIT") {
            clearAllSections();
            showVoicebotModal();
            log("Voicebot started ‚Äî speak!");
            document.body.classList.add("voicebot-active");
            document.getElementById("exitVoicebot").style.display =
              "inline-block";
            document.getElementById("ask").disabled = true;
          } else if (msg.type === "INTERRUPT_PLAYBACK") {
            log("User has started Speaking.");
            stopPlayback();
          } else if (msg.type === "VOICEBOT_EXIT") {
            log("Voicebot ended");
            hideVoicebotModal();
            exitVoicebotMode();
          } else if (msg.type === "FUNCTION_CALL") {
            if (msg.function === "show_on_board") {
              const args =
                typeof msg.args === "string" ? JSON.parse(msg.args) : msg.args;
              addToVoicebotBoard(args.content, args.type);
            }
          } else if (msg.type === "DIAGRAM_INITIATED") {
            showDiagramGenerating();
          } else if (msg.type === "DIAGRAM_READY") {
            showDiagramReady(msg.url);
          } else if (msg.type === "DIAGRAM_FAILED") {
            showDiagramError();
          } else if (msg.type === "AUDIO_DELTA") {
            playRealtime(msg.delta);
          } else if (msg.type === "TURN_COMPLETE") {
            log("Turn complete - waiting for next interaction");
          }
        };

        ws.onclose = () => log("WebSocket closed");
      }

      // ---------- Explanation Flow ----------
      function sendPart(part, idx = null) {
        const payload = idx !== null ? { part, index: idx } : { part };
        ws.send(JSON.stringify(payload));
      }

      function transition(event) {
        log(`EVENT: ${event} | STATE: ${STATE}`);
        switch (STATE) {
          case "IDLE":
            if (event === "START") {
              STATE = "PLAYING_CONTEXT";
              sendPart("CONTEXT");
            }
            break;
          case "PLAYING_CONTEXT":
            if (event === "AUDIO_FINISHED") {
              STATE = "PLAYING_STEP";
              CURRENT_STEP = 0;
              sendPart("EXPLANATION_STEP", 0);
            }
            break;
          case "PLAYING_STEP":
            if (event === "AUDIO_FINISHED") {
              CURRENT_STEP++;
              if (CURRENT_STEP < TOTAL_STEPS) {
                sendPart("EXPLANATION_STEP", CURRENT_STEP);
              } else {
                STATE = "PLAYING_CONCLUSION";
                sendPart("CONCLUSION");
              }
            }
            break;
          case "PLAYING_CONCLUSION":
            if (event === "AUDIO_FINISHED") {
              STATE = "IDLE";
              setSubtitle("Finished! üéâ");
            }
            break;
          case "PAUSED":
            if (event === "RESUME") {
              STATE = SAVED_STATE || "PLAYING_STEP";
              playAudio();
            }
            break;
        }
      }

      // ---------- Audio Utils (Streaming PCM) ----------
      let streamQueue = [],
        streamPlaying = false,
        streamEndReceived = false;
      let scheduledTime = 0;
      let activeAudioSources = [];

      function hexToBytes(h) {
        const a = new Uint8Array(h.length / 2);
        for (let i = 0; i < a.length; i++)
          a[i] = parseInt(h.substr(i * 2, 2), 16);
        return a;
      }

      function stopAllTTSAudio() {
        activeAudioSources.forEach((source) => {
          try {
            source.stop();
            source.disconnect();
          } catch (e) {}
        });
        activeAudioSources = [];

        streamQueue = [];
        streamPlaying = false;
        streamEndReceived = false;
        scheduledTime = 0;
        currentSrc = null;

        log("All TTS audio stopped and queue cleared");
      }

      function resetAudioState() {
        // Complete reset of all audio streaming state
        stopAllTTSAudio();

        // Also clear any pending audio context
        if (audioCtx && audioCtx.state !== "closed") {
          // Don't close it, just ensure it's ready
        }

        log("Audio state completely reset");
      }

      function addAudio(hexData) {
        const bytes = hexToBytes(hexData);
        const int16 = new Int16Array(bytes.buffer);
        const float32 = new Float32Array(int16.length);
        for (let i = 0; i < int16.length; i++) {
          float32[i] = int16[i] / 32768.0;
        }
        streamQueue.push(float32);

        if (!streamPlaying && !isPaused && MODE === "EXPLANATION") {
          playStreamQueue();
        }
      }

      async function playStreamQueue() {
        if (streamPlaying || isPaused || MODE !== "EXPLANATION") return;
        streamPlaying = true;
        scheduledTime = audioCtx.currentTime;
        log("Started stream playback");

        const processQueue = () => {
          if (isPaused || MODE !== "EXPLANATION") return;

          while (streamQueue.length > 0) {
            const samples = streamQueue.shift();
            const buffer = audioCtx.createBuffer(1, samples.length, 24000);
            buffer.copyToChannel(samples, 0);

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(audioCtx.destination);
            currentSrc = source;
            activeAudioSources.push(source);

            source.start(scheduledTime);
            scheduledTime += buffer.duration;
          }

          if (!streamEndReceived) {
            setTimeout(processQueue, 100);
          } else {
            const remainingTime = (scheduledTime - audioCtx.currentTime) * 1000;
            setTimeout(
              () => {
                log("Stream playback finished");
                streamPlaying = false;
                streamQueue = [];
                streamEndReceived = false;
                scheduledTime = 0;
                currentSrc = null;
                activeAudioSources = [];
                if (!isPaused && MODE === "EXPLANATION") {
                  transition("AUDIO_FINISHED");
                }
              },
              Math.max(0, remainingTime),
            );
          }
        };

        processQueue();
      }

      async function playAudio() {
        log(
          `playAudio called: queue=${streamQueue.length}, playing=${streamPlaying}, ended=${streamEndReceived}`,
        );
        streamEndReceived = true;

        if (!streamPlaying && !isPaused && MODE === "EXPLANATION") {
          if (streamQueue.length > 0) {
            playStreamQueue();
          } else {
            log("No audio to play, transitioning immediately");
            transition("AUDIO_FINISHED");
          }
        }
      }

      // ---------- Voicebot ----------
      async function startVoicebot() {
        if (MODE !== "EXPLANATION") return;

        SAVED_STATE = STATE;
        SAVED_STEP = CURRENT_STEP;

        log(
          `Voicebot requested. Saving state: ${STATE}, step: ${CURRENT_STEP}`,
        );

        stopAllTTSAudio();
        clearAllSections();

        MODE = "VOICEBOT";
        isPaused = true;
        isPlaying = false;

        ws.send(JSON.stringify({ part: "VOICEBOT", index: CURRENT_STEP }));

        await initMic();
      }

      function exitVoicebotMode() {
        if (micStream) {
          micStream.getTracks().forEach((track) => track.stop());
          micStream = null;
        }
        if (node) {
          node.disconnect();
          node = null;
        }

        playQ = [];
        playing = false;
        if (currentSource) {
          try {
            currentSource.stop();
            currentSource.disconnect();
          } catch (e) {}
          currentSource = null;
        }
        if (currentContext) {
          currentContext.close();
          currentContext = null;
        }

        document.body.classList.remove("voicebot-active");
        document.getElementById("exitVoicebot").style.display = "none";
        document.getElementById("ask").disabled = false;

        MODE = "EXPLANATION";
        isPaused = false;

        // CRITICAL: Reset all audio streaming state before resuming
        resetAudioState();

        STATE = SAVED_STATE || "PLAYING_STEP";
        CURRENT_STEP = SAVED_STEP !== null ? SAVED_STEP : CURRENT_STEP;

        log(`Resuming from state: ${STATE}, step: ${CURRENT_STEP}`);

        setSubtitle("Resuming explanation...");

        if (SAVED_STATE === "PLAYING_CONTEXT") {
          sendPart("CONTEXT");
        } else if (SAVED_STATE === "PLAYING_STEP") {
          sendPart("EXPLANATION_STEP", CURRENT_STEP);
        } else if (SAVED_STATE === "PLAYING_CONCLUSION") {
          sendPart("CONCLUSION");
        } else {
          sendPart("EXPLANATION_STEP", CURRENT_STEP);
        }
      }

      let micStream = null,
        node = null;
      async function initMic() {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { sampleRate: 24000, noiseSuppression: true },
        });
        const ctx = new AudioContext({ sampleRate: 24000 });
        await ctx.audioWorklet.addModule(
          URL.createObjectURL(
            new Blob(
              [
                `
    class P extends AudioWorkletProcessor{
      process(i){if(i&&i[0]&&i[0][0]){const f=i[0][0];const s=new Int16Array(f.length);
      for(let j=0;j<f.length;j++)s[j]=Math.max(-32768,Math.min(32767,f[j]*32768));
      this.port.postMessage(s.buffer);}return true;}
    }registerProcessor("p",P);
  `,
              ],
              { type: "application/javascript" },
            ),
          ),
        );
        const n = new AudioWorkletNode(ctx, "p");
        n.port.onmessage = (e) => {
          const hex = Array.from(new Uint8Array(e.data))
            .map((b) => b.toString(16).padStart(2, "0"))
            .join("");
          ws.send(JSON.stringify({ type: "audio_chunk", chunk: hex }));
        };
        const src = ctx.createMediaStreamSource(stream);
        src.connect(n);
        n.connect(ctx.destination);
        micStream = stream;
        node = n;
        log("üéô Mic active");
      }

      // ---------- Realtime Playback ----------
      let playQ = [],
        playing = false,
        currentSource = null,
        currentContext = null;

      async function playRealtime(b64) {
        playQ.push(b64);
        if (!playing) await playNext();
      }

      function stopPlayback() {
        playing = false;

        if (currentSource) {
          try {
            currentSource.stop();
            currentSource.disconnect();
          } catch (e) {}
          currentSource = null;
        }

        if (currentContext) {
          currentContext.close();
          currentContext = null;
        }

        playQ = [];
        log("Playback interrupted and queue cleared");
      }

      async function playNext() {
        if (playQ.length === 0) {
          playing = false;
          currentSource = null;
          currentContext = null;
          return;
        }

        playing = true;
        const b = atob(playQ.shift());
        const u8 = new Uint8Array(b.length);
        for (let i = 0; i < b.length; i++) u8[i] = b.charCodeAt(i);

        const i16 = new Int16Array(u8.buffer);
        const f32 = new Float32Array(i16.length);
        for (let i = 0; i < i16.length; i++) f32[i] = i16[i] / 32768.0;

        const ctx = new AudioContext({ sampleRate: 24000 });
        currentContext = ctx;

        const ab = ctx.createBuffer(1, f32.length, 24000);
        ab.copyToChannel(f32, 0);

        const s = ctx.createBufferSource();
        currentSource = s;
        s.buffer = ab;
        s.connect(ctx.destination);

        s.onended = () => {
          ctx.close();
          currentContext = null;
          currentSource = null;
          playNext();
        };

        s.start();
      }

      // ---------- Buttons ----------
      document.getElementById("start").onclick = async () => {
        await initAudio();
        transition("START");
      };

      document.getElementById("pause").onclick = () => {
        SAVED_STATE = STATE;
        SAVED_STEP = CURRENT_STEP;
        isPaused = true;
        stopAllTTSAudio();
        isPlaying = false;
        STATE = "PAUSED";
      };

      document.getElementById("resume").onclick = async () => {
        if (STATE === "PAUSED") {
          await initAudio();
          isPaused = false;
          transition("RESUME");
        }
      };

      document.getElementById("ask").onclick = startVoicebot;

      document.getElementById("exitVoicebot").onclick = () => {
        ws.send(JSON.stringify({ type: "exit_voicebot" }));
      };

      // ---------- Init ----------
      connect();
      log("üöÄ Ready");
    </script>
  </body>
</html>
